package com.jgranados.koky.interpreter.parser;

import com.jgranados.koky.interpreter.lexer.Lexer;
import com.jgranados.koky.interpreter.lexer.languages.LexerEs;
import com.jgranados.koky.interpreter.lexer.languages.LexerKiche;
import com.jgranados.koky.interpreter.lexer.languages.LexerAll;
import com.jgranados.koky.instructions.logic.Languages;
import com.jgranados.koky.instructions.logic.Messages;
import com.jgranados.koky.interpreter.token.Token;
import com.jgranados.koky.interpreter.expr.Expr;
import com.jgranados.koky.interpreter.symbolstable.SymbolsTable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import com.jgranados.koky.instructions.*;
import com.jgranados.koky.instructions.graphicinstructions.*;
import com.jgranados.koky.instructions.varinstructions.*;
import java_cup.runtime.*;


parser code {:
        private Lexer lexerEnglish;
        private LexerEs lexerEs;
        private LexerKiche lexerKi;
        private LexerAll lexerAll;
        private List<String> errorsList;
        private SymbolsTable symTable;

	// Connect this parser to a scanner!
        
        public Parser(Scanner scan, SymbolsTable symTable){
             super(scan);
             if (Languages.ALL.getTypeLanguage()==true) {
                lexerAll = (LexerAll) scan;
                methodAuxAll(lexerAll);
            }else if (Languages.ENGLISH.getTypeLanguage()==true) {
                lexerEnglish = (Lexer) scan;
                methodAuxEn(lexerEnglish);
            }else if (Languages.SPANISH.getTypeLanguage()==true) {
                lexerEs = (LexerEs) scan;
                methodAuxSp(lexerEs);
            }else if (Languages.KICHE.getTypeLanguage()==true) {
                lexerKi = (LexerKiche) scan;
                methodAuxKi(lexerKi);
            }
        }

        private void methodAuxAll(LexerAll lex){
            this.errorsList = lex.getErrorsList();
            tableSym();
        }
        private void methodAuxSp(LexerEs lex){
            this.errorsList = lex.getErrorsList();
            tableSym();
        }
        private void methodAuxEn(Lexer lex){
            this.errorsList = lex.getErrorsList();
            tableSym();
        }
        private void methodAuxKi(LexerKiche lex){
            this.errorsList = lex.getErrorsList();
            tableSym();
        }
        
        private void tableSym(){
            this.symTable = symTable;
        }
       
        @Override
        public void syntax_error(Symbol st) {
            //validation to respond according to language   
            if (Languages.ALL.getTypeLanguage()==true) {
                getAnalyzingFile(st, Languages.ALL);
            }else if (Languages.ENGLISH.getTypeLanguage()==true) {
                getAnalyzingFile(st, Languages.ENGLISH);
            }else if (Languages.SPANISH.getTypeLanguage()==true) {
                getAnalyzingFile(st, Languages.SPANISH);
            }else if (Languages.KICHE.getTypeLanguage()==true) {
                getAnalyzingFile(st, Languages.KICHE);
            }  
        }
        
        private void getAnalyzingFile(Symbol st, Enum typeLanguage){
                if (st.sym != sym.LINE_TERMINATOR) {
                    Token token = (Token) st.value;
                    report_error(Messages.reportError(token.getLexeme(),token.getLine(),token.getColumn()),null);
                    if (typeLanguage.equals(Languages.KICHE)) {
                        if (lexerKi.isAnalyzingFile()) {
                            errorsList(token);
                        } else {
                            errorsList(token);
                        }
                    }else if (typeLanguage.equals(Languages.SPANISH)) {
                        if (lexerEs.isAnalyzingFile()) {
                            errorsList(token);
                        } else {
                            errorsList(token);
                        }
                    }else if (typeLanguage.equals(Languages.ENGLISH)) {
                        if (lexerEnglish.isAnalyzingFile()) {
                            errorsList(token);
                        } else {
                            errorsList(token);
                        }
                    }else if (typeLanguage.equals(Languages.ALL)) {
                        if (lexerAll.isAnalyzingFile()) {
                            errorsList(token);
                        } else {
                            errorsList(token);
                        }
                    }
                }
        }

        private void getColorError(Enum typeLanguage, int token){
                    if (typeLanguage.equals(Languages.KICHE)) {
                        if (lexerKi.isAnalyzingFile()) {
                            errorsList.add(Messages.colorErrorMessage(token));
                        } else {
                            errorsList.add(Messages.colorErrorMessage(token));
                        }
                    }else if (typeLanguage.equals(Languages.SPANISH)) {
                        if (lexerEs.isAnalyzingFile()) {
                            errorsList.add(Messages.colorErrorMessage(token));
                        } else {
                            errorsList.add(Messages.colorErrorMessage(token));
                        }
                    }else if (typeLanguage.equals(Languages.ENGLISH)) {
                        if (lexerEnglish.isAnalyzingFile()) {
                           errorsList.add(Messages.colorErrorMessage(token));
                        } else {
                            errorsList.add(Messages.colorErrorMessage(token));
                        }
                    }else if (typeLanguage.equals(Languages.ALL)) {
                        if (lexerAll.isAnalyzingFile()) {
                           errorsList.add(Messages.colorErrorMessage(token));
                        } else {
                           errorsList.add(Messages.colorErrorMessage(token));
                        }
                    }
        }
        
        private void errorsList(Token token){
            errorsList.add(Messages.errorCup(token.getLexeme()));
        }   

        public void addSemanticError(String msg) {
            this.errorsList.add(msg);
        }

:}

/* Terminals (tokens returned by the scanner). */
terminal Token          LINE_TERMINATOR, INTEGER_LITERAL, HEXA_LITERAL, ID, COMMA;
terminal Token          OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAR, CLOSE_PAR, PLUS;
terminal Token          MINUS, MULT, DIV, EQ, FORWARD, BACKWARD, RIGHT, LEFT;
terminal Token          CLEARS, PENUP, PENDOWN, TOCENTER, COLOR, POSITIONXY;
terminal Token          POSITIONX, POSITIONY, HIDETURTLE, SHOWTURTLE, TOERASE;
terminal Token          TODRAW, REPEAT,WIDTH;

/* Non-terminals */
non terminal List<Instruction>          program, instructions, instructionsRepeat;
non terminal Instruction                instruction, instructionRepeat;
non terminal                            syncToken;
non terminal Expr                       expr;

/* precedence */
precedence left     PLUS, MINUS;
precedence left     MULT, DIV;

/* The grammar */
start with program;

program ::= instructions:list
                {: RESULT = list; :}
            ;

instructions ::= instructions:list instruction:ins
                    {:  
                        list.add(ins);
                        RESULT = list;
                    :}
                | instruction:ins
                    {:
                        List<Instruction> instructions = new ArrayList<>();
                        instructions.add(ins);
                        RESULT = instructions;
                    :}
                ;

instruction ::=	 FORWARD expr:e  LINE_TERMINATOR
                    {:  
                        System.out.println("un forward con n = " + e);
                        RESULT = new ForwardInstruction(e);
                    :}
                | BACKWARD expr:e  LINE_TERMINATOR
                    {:  
                        System.out.println("un backward con n = " + e);
                        RESULT = new BackwardInstruction(e);
                    :}
                | RIGHT expr:e  LINE_TERMINATOR
                    {:  
                        System.out.println("un RIGHT con n = " + e);
                        RESULT = new RightInstruction(e);
                    :}
                | LEFT expr:e  LINE_TERMINATOR
                    {:  
                        System.out.println("un LEFT con n = " + e);
                        RESULT = new LeftInstruction(e);
                    :}
                | CLEARS  LINE_TERMINATOR
                    {:  
                        System.out.println("un CLEAR ");
                        RESULT = new ClearsInstruction();
                    :}
                | PENUP  LINE_TERMINATOR
                    {:  
                        System.out.println("un PENUP ");
                        RESULT = new TogglePenInstruction(true);
                    :}
                | PENDOWN  LINE_TERMINATOR
                    {:  
                        System.out.println("un PENDOWN ");
                        RESULT = new TogglePenInstruction(false);
                    :}
                | TOCENTER  LINE_TERMINATOR
                    {:  
                        System.out.println("un TOCENTER ");
                        RESULT = new ToCenterInstruction();
                    :}
                | COLOR:color expr:e  LINE_TERMINATOR
                    {:  
                        System.out.println("un color ");
                        RESULT = new ColorInstruction(e);
                        if (e.operate() > 0 && e.operate() < 10) {
                            RESULT = new ColorInstruction(e);
                        } else {
                            if (Languages.ALL.getTypeLanguage()==true) {
                                if (Languages.ALL.getTypeLanguage()==true) {
                                getColorError(Languages.ALL, e.operate());
                            }else if (Languages.ENGLISH.getTypeLanguage()==true) {
                                getColorError(Languages.ENGLISH, e.operate());
                            }else if (Languages.SPANISH.getTypeLanguage()==true) {
                                getColorError(Languages.SPANISH, e.operate());
                            }else if (Languages.KICHE.getTypeLanguage()==true) {
                                getColorError(Languages.KICHE, e.operate());
                            }
                            
                            RESULT = new EmptyInstruction();
                            }
                        }
                    :}
                | COLOR HEXA_LITERAL:e  LINE_TERMINATOR
                    {:  
                        System.out.println("un color ");
                        RESULT = new ColorInstruction(e.getLexeme());
                    :}
                | POSITIONXY expr:ex COMMA expr:ey  LINE_TERMINATOR
                    {:  
                        System.out.println("un POSITIONXY ");
                        RESULT = new PositionXYInstruction(ex, ey);
                    :}
                | POSITIONX expr:ex  LINE_TERMINATOR
                    {:  
                        System.out.println("un POSITIONX ");
                        RESULT = new PositionXInstruction(ex);
                    :}
                | POSITIONY expr:ey  LINE_TERMINATOR
                    {:  
                        System.out.println("un POSITIONY ");
                        RESULT = new PositionYInstruction(ey);
                    :}
                | HIDETURTLE  LINE_TERMINATOR
                    {:  
                        System.out.println("un HIDETURTLE ");
                        RESULT = new ToggleTurtleInstruction(false);
                    :}
                | SHOWTURTLE  LINE_TERMINATOR
                    {:  
                        System.out.println("un SHOWTURTLE ");
                        RESULT = new ToggleTurtleInstruction(true);
                    :}
                | TOERASE  LINE_TERMINATOR
                    {:  
                        System.out.println("un TOERASE ");
                        RESULT = new ToggleDrawInstruction(false);
                    :}
                | TODRAW  LINE_TERMINATOR
                    {:  
                        System.out.println("un TODRAW ");
                        RESULT = new ToggleDrawInstruction(true);
                    :}
                | WIDTH expr:e LINE_TERMINATOR
                    {:
                        if(e.operate() > 0 && e.operate() < 16) {
                            RESULT = new WidthInstruction(e);
                        } else {
                            errorsList.add(Messages.widthErrorMessage(e.operate()));
                        }
                    :}
                | REPEAT expr:e OPEN_BRACKET instructionsRepeat:inst CLOSE_BRACKET LINE_TERMINATOR
                    {:
                        System.out.println("un REPEAT CON " + e);
                        RESULT = new RepeatInstruction(e, inst);
                    :}
                | ID:e LINE_TERMINATOR
                    {:
                        symTable.addId(e, 0, lexerEnglish.isAnalyzingFile());
                        RESULT = new EmptyInstruction();
                    :}
                | ID:e EQ expr:ex LINE_TERMINATOR
                    {:
                        RESULT = new VarAssignationInstruction(symTable, e, ex);
                    :}
                | LINE_TERMINATOR
                    {:  
                        System.out.println("Vacio, no hago nada");
                        RESULT = new EmptyInstruction();
                    :}
                /*| FORWARD error:e syncToken {: System.out.println("--------Error en fd  "+ eleft + eright); RESULT = new EmptyInstruction(); :}*/
                /* | error:e syncToken {: System.out.println("--------Error en fin linea  "); RESULT = new EmptyInstruction(); :}*/
                | error:e syncToken {: System.out.println("--------Error nnn  " + eleft + eright); RESULT = new EmptyInstruction(); :}
		;

instructionsRepeat ::=  instructionsRepeat:list instructionRepeat:ins
                            {:  
                                list.add(ins);
                                RESULT = list;
                            :}
                        | instructionRepeat:ins
                            {:
                                List<Instruction> instructions = new ArrayList<>();
                                instructions.add(ins);
                                RESULT = instructions;
                            :}
                        ;

instructionRepeat ::=	 FORWARD expr:e
                    {:  
                        System.out.println("un forward con n = " + e);
                        RESULT = new ForwardInstruction(e);
                    :}
                | BACKWARD expr:e
                    {:  
                        System.out.println("un backward con n = " + e);
                        RESULT = new BackwardInstruction(e);
                    :}
                | RIGHT expr:e 
                    {:  
                        System.out.println("un RIGHT con n = " + e);
                        RESULT = new RightInstruction(e);
                    :}
                | LEFT expr:e
                    {:  
                        System.out.println("un LEFT con n = " + e);
                        RESULT = new LeftInstruction(e);
                    :}
                | CLEARS
                    {:  
                        System.out.println("un CLEAR ");
                        RESULT = new ClearsInstruction();
                    :}
                | PENUP
                    {:  
                        System.out.println("un PENUP ");
                        RESULT = new TogglePenInstruction(true);
                    :}
                | PENDOWN
                    {:  
                        System.out.println("un PENDOWN ");
                        RESULT = new TogglePenInstruction(false);
                    :}
                | TOCENTER
                    {:  
                        System.out.println("un TOCENTER ");
                        RESULT = new ToCenterInstruction();
                    :}
                | COLOR:color expr:e
                    {:  
                        System.out.println("un color ");
                        RESULT = new ColorInstruction(e);
                         if (e.operate() > 0 && e.operate() < 10) {
                            RESULT = new ColorInstruction(e);
                        } else {
                            if (Languages.ALL.getTypeLanguage()==true) {
                                if (Languages.ALL.getTypeLanguage()==true) {
                                getColorError(Languages.ALL, e.operate());
                            }else if (Languages.ENGLISH.getTypeLanguage()==true) {
                                getColorError(Languages.ENGLISH, e.operate());
                            }else if (Languages.SPANISH.getTypeLanguage()==true) {
                                getColorError(Languages.SPANISH, e.operate());
                            }else if (Languages.KICHE.getTypeLanguage()==true) {
                                getColorError(Languages.KICHE, e.operate());
                            }
                            
                            RESULT = new EmptyInstruction();
                            }
                        }
                    :}
                | COLOR HEXA_LITERAL:e
                    {:  
                        System.out.println("un color ");
                        RESULT = new ColorInstruction(e.getLexeme());
                    :}
                | POSITIONXY expr:ex COMMA expr:ey
                    {:  
                        System.out.println("un POSITIONXY ");
                        RESULT = new PositionXYInstruction(ex, ey);
                    :}
                | POSITIONX expr:ex
                    {:  
                        System.out.println("un POSITIONX ");
                        RESULT = new PositionXInstruction(ex);
                    :}
                | POSITIONY expr:ey
                    {:  
                        System.out.println("un POSITIONY ");
                        RESULT = new PositionYInstruction(ey);
                    :}
                | HIDETURTLE
                    {:  
                        System.out.println("un HIDETURTLE ");
                        RESULT = new ToggleTurtleInstruction(false);
                    :}
                | SHOWTURTLE
                    {:  
                        System.out.println("un SHOWTURTLE ");
                        RESULT = new ToggleTurtleInstruction(true);
                    :}
                | TOERASE
                    {:  
                        System.out.println("un TOERASE ");
                        RESULT = new ToggleDrawInstruction(false);
                    :}
                | TODRAW
                    {:  
                        System.out.println("un TODRAW ");
                        RESULT = new ToggleDrawInstruction(true);
                    :}
                | WIDTH expr:e 
                    {:
                        if(e.operate() > 0 && e.operate() < 16) {
                            RESULT = new WidthInstruction(e);
                        } else {
                            errorsList.add(Messages.widthErrorMessage(e.operate()));
                        }
                    :}
                | REPEAT expr:e OPEN_BRACKET instructionsRepeat:inst CLOSE_BRACKET
                    {:
                        System.out.println("un REPEAT CON " + e);
                        RESULT = new RepeatInstruction(e, inst);
                    :}
                | ID:e EQ expr:ex
                    {:
                        RESULT = new VarAssignationInstruction(symTable, e, ex);
                    :}
                /*| FORWARD error:e syncToken {: System.out.println("--------Error en fd  "); RESULT = new EmptyInstruction(); :}*/
                /* | error:e syncToken {: System.out.println("--------Error en fin linea  "); RESULT = new EmptyInstruction(); :}*/
                | error:e CLOSE_BRACKET {: System.out.println("--------Error nnn  "); RESULT = new EmptyInstruction(); :}
		;

expr ::=    expr:e1 PLUS expr:e2
                {:
                    RESULT = new Expr(sym.PLUS, e1, e2);
                :}
            | expr:e1 MINUS expr:e2
                {:
                    RESULT = new Expr(sym.MINUS, e1, e2);
                :}
            | expr:e1 MULT expr:e2
                {:
                    RESULT = new Expr(sym.MULT, e1, e2);
                :}
            | expr:e1 DIV expr:e2
                {:
                    RESULT = new Expr(sym.DIV, e1, e2);
                :}
            | OPEN_PAR expr:e CLOSE_PAR
                {:
                    RESULT = e;
                :}
            | ID:e
                {:
                    if (symTable.exists(e, lexerEnglish.isAnalyzingFile())) {
                        RESULT = new Expr(e, symTable);
                    } else {
                        RESULT = null;
                    }
                :}
            | INTEGER_LITERAL:e
                {:
                    RESULT = new Expr(e.getLexeme());
                :}
            ;

syncToken ::=   FORWARD
                | LINE_TERMINATOR 
                ;